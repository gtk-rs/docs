<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Context` struct in crate `cairo`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Context">

    <title>cairo::Context - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'><a href='index.html'>cairo</a></p><script>window.sidebarCurrent = {name: 'Context', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>cairo</a>::<wbr><a class='struct' href=''>Context</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span><a id='src-722' class='srclink' href='../src/cairo/context.rs.html#43' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct Context(_);</pre><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h3><div class='impl-items'><h4 id='method.ensure_status' class='method'><code>fn <a href='#method.ensure_status' class='fnname'>ensure_status</a>(&amp;self)</code></h4>
<h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>&lt;T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../cairo/struct.Surface.html' title='cairo::Surface'>Surface</a>&gt;&gt;(target: &amp;T) -&gt; <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h4>
<div class='docblock'><p>Creates a new Context with all graphics state parameters set to default values
and with target as a target surface. The target surface should be constructed
with a backend-specific function such as cairo_image_surface_create() (or any other
Context::backend_surface_create() variant).</p>

<p>This function references target , so you can immediately call Surface::drop() on
it if you don&#39;t need to maintain a separate reference to it.</p>
</div><h4 id='method.status' class='method'><code>fn <a href='#method.status' class='fnname'>status</a>(&amp;self) -&gt; <a class='enum' href='../cairo/enum.Status.html' title='cairo::Status'>Status</a></code></h4>
<div class='docblock'><p>Checks whether an error has previously occurred for this context.</p>
</div><h4 id='method.save' class='method'><code>fn <a href='#method.save' class='fnname'>save</a>(&amp;self)</code></h4>
<div class='docblock'><p>Makes a copy of the current state of self and saves it on an internal stack of
saved states for self. When Context::restore() is called, self will be restored to
the saved state. Multiple calls to Context::save() and Context::restore() can be nested;
each call to Context::restore() restores the state from the matching paired
Context::save().</p>

<p>It isn&#39;t necessary to clear all saved states before a Context is freed. If the
reference count of a Context drops to zero in response to a call to Context::drop(), any
saved states will be freed along with the Context.</p>
</div><h4 id='method.restore' class='method'><code>fn <a href='#method.restore' class='fnname'>restore</a>(&amp;self)</code></h4>
<div class='docblock'><p>Restores self to the state saved by a preceding call to Context::save() and removes
that state from the stack of saved states.</p>
</div><h4 id='method.push_group' class='method'><code>fn <a href='#method.push_group' class='fnname'>push_group</a>(&amp;self)</code></h4>
<div class='docblock'><p>Temporarily redirects drawing to an intermediate surface known as a group. The
redirection lasts until the group is completed by a call to Context::pop_group()
or Context::pop_group_to_source(). These calls provide the result of any drawing
to the group as a pattern, (either as an explicit object, or set as the source
pattern).</p>

<p>This group functionality can be convenient for performing intermediate compositing.
One common use of a group is to render objects as opaque within the group, (so that
they occlude each other), and then blend the result with translucence onto the
destination.</p>

<p>Groups can be nested arbitrarily deep by making balanced calls to Context::push_group()
/ Context::pop_group(). Each call pushes  /pops the new target group onto/from a stack.</p>

<p>The Context::push_group() function calls Context::save() so that any changes to the
graphics state will not be visible outside the group, (the pop_group functions call
Context::restore()).</p>

<p>By default the intermediate group will have a content type of Content::ColorAlpha.
Other content types can be chosen for the group by using
Context::push_group_with_content() instead.</p>

<p>As an example, here is how one might fill and stroke a path with translucence, but
without any portion of the fill being visible under the stroke:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>cr</span>.<span class='ident'>push_group</span>();
<span class='ident'>cr</span>.<span class='ident'>set_source</span> (<span class='ident'>fill_pattern</span>);
<span class='ident'>cr</span>.<span class='ident'>fill_preserve</span>();
<span class='ident'>cr</span>.<span class='ident'>set_source</span>();
<span class='ident'>cr</span>.<span class='ident'>stroke</span>();
<span class='ident'>cr</span>.<span class='ident'>pop_group_to_source</span>();
<span class='ident'>cr</span>.<span class='ident'>paint_with_alpha</span>(<span class='ident'>alpha</span>);</pre>
</div><h4 id='method.pop_group' class='method'><code>fn <a href='#method.pop_group' class='fnname'>pop_group</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html' title='alloc::boxed::Box'>Box</a>&lt;<a class='trait' href='../cairo/trait.Pattern.html' title='cairo::Pattern'>Pattern</a>&gt;</code></h4>
<div class='docblock'><p>Terminates the redirection begun by a call to Context::push_group() or
Context::push_group_with_content() and returns a new pattern containing the results
of all drawing operations performed to the group.</p>

<p>The Context::pop_group() function calls Context::restore(), (balancing a call to
Context::save() by the push_group function), so that any changes to the graphics
state will not be visible outside the group.</p>
</div><h4 id='method.pop_group_to_source' class='method'><code>fn <a href='#method.pop_group_to_source' class='fnname'>pop_group_to_source</a>(&amp;self)</code></h4>
<div class='docblock'><p>Terminates the redirection begun by a call to Context::push_group() or
Context::push_group_with_content() and installs the resulting pattern as the
source pattern in the given cairo context.</p>

<p>The behavior of this function is equivalent to the sequence of operations:</p>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>group</span> <span class='op'>=</span> <span class='ident'>context</span>.<span class='ident'>pop_group</span>();
<span class='ident'>context</span>.<span class='ident'>set_source</span>(<span class='ident'>group</span>);</pre>

<p>but is more convenient as their is no need for a variable to store the short-lived
pointer to the pattern.</p>

<p>The Context::pop_group() function calls Context::restore(), (balancing a call to
Context::save() by the push_group function), so that any changes to the graphics state
will not be visible outside the group.</p>
</div><h4 id='method.set_source_rgb' class='method'><code>fn <a href='#method.set_source_rgb' class='fnname'>set_source_rgb</a>(&amp;self, red: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, green: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, blue: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Sets the source pattern within self to an opaque color. This opaque color will then be
used for any subsequent drawing operation until a new source pattern is set.</p>

<p>The color components are floating point numbers in the range 0 to 1.</p>

<p>If the values passed in are outside that range, they will be clamped.</p>

<p>The default source pattern is opaque black, (that is, it is equivalent to
Context::set_source_rgb(0.0, 0.0, 0.0)).</p>
</div><h4 id='method.set_source_rgba' class='method'><code>fn <a href='#method.set_source_rgba' class='fnname'>set_source_rgba</a>(&amp;self, red: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, green: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, blue: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, alpha: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Sets the source pattern within self to a translucent color. This color will then be used
for any subsequent drawing operation until a new source pattern is set.</p>

<p>The color and alpha components are floating point numbers in the range 0 to 1. If the
values passed in are outside that range, they will be clamped.</p>

<p>The default source pattern is opaque black, (that is, it is equivalent to
Context::set_source_rgba(0.0, 0.0, 0.0, 1.0)).</p>
</div><h4 id='method.set_source' class='method'><code>fn <a href='#method.set_source' class='fnname'>set_source</a>(&amp;self, source: &amp;<a class='trait' href='../cairo/trait.Pattern.html' title='cairo::Pattern'>Pattern</a>)</code></h4>
<div class='docblock'><p>Sets the source pattern within self to source. This pattern will then be used for any
subsequent drawing operation until a new source pattern is set.</p>

<p>Note: The pattern&#39;s transformation matrix will be locked to the user space in effect
at the time of Context::set_source(). This means that further modifications of the
current transformation matrix will not affect the source pattern. See
Pattern::set_matrix().</p>

<p>The default source pattern is a solid pattern that is opaque black, (that is, it is
equivalent to Context::set_source_rgb(0.0, 0.0, 0.0)).</p>
</div><h4 id='method.get_source' class='method'><code>fn <a href='#method.get_source' class='fnname'>get_source</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html' title='alloc::boxed::Box'>Box</a>&lt;<a class='trait' href='../cairo/trait.Pattern.html' title='cairo::Pattern'>Pattern</a>&gt;</code></h4>
<div class='docblock'><p>Gets the current source pattern for self.</p>
</div><h4 id='method.set_source_surface' class='method'><code>fn <a href='#method.set_source_surface' class='fnname'>set_source_surface</a>&lt;T: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../cairo/struct.Surface.html' title='cairo::Surface'>Surface</a>&gt;&gt;(&amp;self, surface: &amp;T, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<h4 id='method.set_antialias' class='method'><code>fn <a href='#method.set_antialias' class='fnname'>set_antialias</a>(&amp;self, antialias: <a class='enum' href='../cairo/enum.Antialias.html' title='cairo::Antialias'>Antialias</a>)</code></h4>
<div class='docblock'><p>Set the antialiasing mode of the rasterizer used for drawing shapes. This value
is a hint, and a particular backend may or may not support a particular value.
At the current time, no backend supports CAIRO_ANTIALIAS_SUBPIXEL when drawing
shapes.</p>

<p>Note that this option does not affect text rendering, instead see
FontOptions::set_antialias().</p>
</div><h4 id='method.get_antialias' class='method'><code>fn <a href='#method.get_antialias' class='fnname'>get_antialias</a>(&amp;self) -&gt; <a class='enum' href='../cairo/enum.Antialias.html' title='cairo::Antialias'>Antialias</a></code></h4>
<div class='docblock'><p>Gets the current shape antialiasing mode, as set by Context::set_antialias().</p>
</div><h4 id='method.set_dash' class='method'><code>fn <a href='#method.set_dash' class='fnname'>set_dash</a>(&amp;self, dashes: <a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a><a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>, offset: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Sets the dash pattern to be used by cairo_stroke(). A dash pattern is specified by dashes,
an array of positive values. Each value provides the length of alternate &quot;on&quot; and &quot;off&quot;
portions of the stroke. The offset specifies an offset into the pattern at which the
stroke begins.</p>

<p>Each &quot;on&quot; segment will have caps applied as if the segment were a separate sub-path. In
particular, it is valid to use an &quot;on&quot; length of 0.0 with Line::CapRound or Line::CapSquare
in order to distributed dots or squares along a path.</p>

<p>Note: The length values are in user-space units as evaluated at the time of stroking.
This is not necessarily the same as the user space at the time of Context::set_dash().</p>

<p>If num_dashes is 0 dashing is disabled.</p>

<p>If num_dashes is 1 a symmetric pattern is assumed with alternating on and off portions
of the size specified by the single value in dashes .</p>

<p>If any value in dashes is negative, or if all values are 0, then self will be put into
an error state with a status of Status::InvalidDash.</p>
</div><h4 id='method.get_dash_count' class='method'><code>fn <a href='#method.get_dash_count' class='fnname'>get_dash_count</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a></code></h4>
<div class='docblock'><p>This function returns the length of the dash array in self (0 if dashing is not
currently in effect).</p>
</div><h4 id='method.get_dash' class='method'><code>fn <a href='#method.get_dash' class='fnname'>get_dash</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>&gt;, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Gets the current dash array. If not NULL, dashes should be big enough to hold at
least the number of values returned by Context::get_dash_count().</p>
</div><h4 id='method.get_dash_dashes' class='method'><code>fn <a href='#method.get_dash_dashes' class='fnname'>get_dash_dashes</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>&gt;</code></h4>
<h4 id='method.get_dash_offset' class='method'><code>fn <a href='#method.get_dash_offset' class='fnname'>get_dash_offset</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a></code></h4>
<h4 id='method.set_fill_rule' class='method'><code>fn <a href='#method.set_fill_rule' class='fnname'>set_fill_rule</a>(&amp;self, fill_rule: <a class='enum' href='../cairo/enum.FillRule.html' title='cairo::FillRule'>FillRule</a>)</code></h4>
<div class='docblock'><p>Set the current fill rule within the cairo context. The fill rule is used to determine
which regions are inside or outside a complex (potentially self-intersecting) path.
The current fill rule affects both Context::fill() and Context::clip(). See FillRule
enum for details on the semantics of each available fill rule.</p>

<p>The default fill rule is FillRule::Winding.</p>
</div><h4 id='method.get_fill_rule' class='method'><code>fn <a href='#method.get_fill_rule' class='fnname'>get_fill_rule</a>(&amp;self) -&gt; <a class='enum' href='../cairo/enum.FillRule.html' title='cairo::FillRule'>FillRule</a></code></h4>
<div class='docblock'><p>Gets the current fill rule, as set by Context::set_fill_rule().</p>
</div><h4 id='method.set_line_cap' class='method'><code>fn <a href='#method.set_line_cap' class='fnname'>set_line_cap</a>(&amp;self, arg: <a class='enum' href='../cairo/enum.LineCap.html' title='cairo::LineCap'>LineCap</a>)</code></h4>
<div class='docblock'><p>Sets the current line cap style within the cairo context. See LineCap enum
for details about how the available line cap styles are drawn.</p>

<p>As with the other stroke parameters, the current line cap style is examined
by Context::stroke(), Context::stroke_extents(), and Context::::stroke_to_path(),
but does not have any effect during path construction.</p>

<p>The default line cap style is LineCap::Butt.</p>
</div><h4 id='method.get_line_cap' class='method'><code>fn <a href='#method.get_line_cap' class='fnname'>get_line_cap</a>(&amp;self) -&gt; <a class='enum' href='../cairo/enum.LineCap.html' title='cairo::LineCap'>LineCap</a></code></h4>
<div class='docblock'><p>Gets the current line cap style, as set by Context::set_line_cap().</p>
</div><h4 id='method.set_line_join' class='method'><code>fn <a href='#method.set_line_join' class='fnname'>set_line_join</a>(&amp;self, arg: <a class='enum' href='../cairo/enum.LineJoin.html' title='cairo::LineJoin'>LineJoin</a>)</code></h4>
<div class='docblock'><p>Sets the current line join style within the cairo context. See LineJoin enum
for details about how the available line join styles are drawn.</p>

<p>As with the other stroke parameters, the current line join style is examined by
Context::stroke(), cairo_stroke_extents(), and Context::stroke_to_path(), but
does not have any effect during path construction.</p>

<p>The default line join style is LineJoin::Miter.</p>
</div><h4 id='method.get_line_join' class='method'><code>fn <a href='#method.get_line_join' class='fnname'>get_line_join</a>(&amp;self) -&gt; <a class='enum' href='../cairo/enum.LineJoin.html' title='cairo::LineJoin'>LineJoin</a></code></h4>
<div class='docblock'><p>Gets the current line join style, as set by Context::set_line_join().</p>
</div><h4 id='method.set_line_width' class='method'><code>fn <a href='#method.set_line_width' class='fnname'>set_line_width</a>(&amp;self, arg: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Sets the current line width within the cairo context. The line width value specifies
the diameter of a pen that is circular in user space, (though device-space pen may be
an ellipse in general due to scaling/shear/rotation of the CTM).</p>

<p>Note: When the description above refers to user space and CTM it refers to the user
space and CTM in effect at the time of the stroking operation, not the user space and
CTM in effect at the time of the call to Context::set_line_width(). The simplest usage
makes both of these spaces identical. That is, if there is no change to the CTM between
a call to Context::set_line_width() and the stroking operation, then one can just pass
user-space values to Context::set_line_width() and ignore this note.</p>

<p>As with the other stroke parameters, the current line width is examined by
Context::stroke(), Context::stroke_extents(), and Context::stroke_to_path(), but does
not have any effect during path construction.</p>

<p>The default line width value is 2.0.</p>
</div><h4 id='method.get_line_width' class='method'><code>fn <a href='#method.get_line_width' class='fnname'>get_line_width</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a></code></h4>
<div class='docblock'><p>This function returns the current line width value exactly as set by
Context::set_line_width(). Note that the value is unchanged even if the CTM has changed
between the calls to Context::set_line_width() and Context::get_line_width().</p>
</div><h4 id='method.set_miter_limit' class='method'><code>fn <a href='#method.set_miter_limit' class='fnname'>set_miter_limit</a>(&amp;self, arg: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Sets the current miter limit within the cairo context.</p>

<p>If the current line join style is set to LineJoin::Miter (see Context::set_line_join()),
the miter limit is used to determine whether the lines should be joined with a bevel
instead of a miter. Cairo divides the length of the miter by the line width. If the result
is greater than the miter limit, the style is converted to a bevel.</p>

<p>As with the other stroke parameters, the current line miter limit is examined by
Context::stroke(), Context::stroke_extents(), and Context::stroke_to_path(), but does
not have any effect during path construction.</p>

<p>The default miter limit value is 10.0, which will convert joins with interior angles less
than 11 degrees to bevels instead of miters. For reference, a miter limit of 2.0 makes the
miter cutoff at 60 degrees, and a miter limit of 1.414 makes the cutoff at 90 degrees.</p>

<p>A miter limit for a desired angle can be computed as: miter limit = 1/sin(angle/2)</p>
</div><h4 id='method.get_miter_limit' class='method'><code>fn <a href='#method.get_miter_limit' class='fnname'>get_miter_limit</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a></code></h4>
<div class='docblock'><p>Gets the current miter limit, as set by Contextset_miter_limit().</p>
</div><h4 id='method.set_tolerance' class='method'><code>fn <a href='#method.set_tolerance' class='fnname'>set_tolerance</a>(&amp;self, arg: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Sets the tolerance used when converting paths into trapezoids. Curved segments of
the path will be subdivided until the maximum deviation between the original path
and the polygonal approximation is less than tolerance . The default value is 0.1.
A larger value will give better performance, a smaller value, better appearance.
(Reducing the value from the default value of 0.1 is unlikely to improve appearance
significantly.) The accuracy of paths within Cairo is limited by the precision of
its internal arithmetic, and the prescribed tolerance is restricted to the smallest
representable internal value.</p>
</div><h4 id='method.get_tolerance' class='method'><code>fn <a href='#method.get_tolerance' class='fnname'>get_tolerance</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a></code></h4>
<div class='docblock'><p>Gets the current tolerance value, as set by Context::set_tolerance().</p>
</div><h4 id='method.clip' class='method'><code>fn <a href='#method.clip' class='fnname'>clip</a>(&amp;self)</code></h4>
<div class='docblock'><p>Establishes a new clip region by intersecting the current clip region with the current
path as it would be filled by Context::fill() and according to the current fill rule
(see Context::set_fill_rule()).</p>

<p>After Context::clip(), the current path will be cleared from the cairo context.</p>

<p>The current clip region affects all drawing operations by effectively masking out any
changes to the surface that are outside the current clip region.</p>

<p>Calling Context::clip() can only make the clip region smaller, never larger. But the
current clip is part of the graphics state, so a temporary restriction of the clip
region can be achieved by calling Context::clip() within a Context::save() /
Context::restore() pair. The only other means of increasing the size of the clip
region is Context::reset_clip().</p>
</div><h4 id='method.clip_preserve' class='method'><code>fn <a href='#method.clip_preserve' class='fnname'>clip_preserve</a>(&amp;self)</code></h4>
<div class='docblock'><p>Establishes a new clip region by intersecting the current clip region with the current
path as it would be filled by Context::fill() and according to the current fill rule
(see Context::set_fill_rule()).</p>

<p>Unlike Context::clip(), Context::clip_preserve() preserves the path within the cairo
context.</p>

<p>The current clip region affects all drawing operations by effectively masking out any
changes to the surface that are outside the current clip region.</p>

<p>Calling Context::clip_preserve() can only make the clip region smaller, never larger.
But the current clip is part of the graphics state, so a temporary restriction of the
clip region can be achieved by calling Context::clip_preserve() within a
Context::save()/cairo_restore() pair. The only other means of increasing the size of
the clip region is Context::reset_clip().</p>
</div><h4 id='method.clip_extents' class='method'><code>fn <a href='#method.clip_extents' class='fnname'>clip_extents</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Computes a bounding box in user coordinates covering the area inside the current clip.</p>
</div><h4 id='method.in_clip' class='method'><code>fn <a href='#method.in_clip' class='fnname'>in_clip</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Tests whether the given point is inside the area that would be visible through the current
clip, i.e. the area that would be filled by a Context::paint() operation.</p>

<p>See Context::clip(), and Context::clip_preserve().</p>
</div><h4 id='method.reset_clip' class='method'><code>fn <a href='#method.reset_clip' class='fnname'>reset_clip</a>(&amp;self)</code></h4>
<div class='docblock'><p>Reset the current clip region to its original, unrestricted state. That is, set the clip
region to an infinitely large shape containing the target surface. Equivalently, if
infinity is too hard to grasp, one can imagine the clip region being reset to the exact
bounds of the target surface.</p>

<p>Note that code meant to be reusable should not call Context::reset_clip() as it will
cause results unexpected by higher-level code which calls Context::clip(). Consider
using Context::save() and Context::restore() around Context::clip() as a more robust
means of temporarily restricting the clip region.</p>
</div><h4 id='method.copy_clip_rectangle_list' class='method'><code>fn <a href='#method.copy_clip_rectangle_list' class='fnname'>copy_clip_rectangle_list</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.RectangleVec.html' title='cairo::RectangleVec'>RectangleVec</a></code></h4>
<div class='docblock'><p>Gets the current clip region as a list of rectangles in user coordinates.</p>

<p>The status in the list may be Status::ClipNotRepresentable to indicate that
the clip region cannot be represented as a list of user-space rectangles.
The status may have other values to indicate other errors.</p>
</div><h4 id='method.fill' class='method'><code>fn <a href='#method.fill' class='fnname'>fill</a>(&amp;self)</code></h4>
<div class='docblock'><p>A drawing operator that fills the current path according to the current fill
rule, (each sub-path is implicitly closed before being filled). After
Context::fill(), the current path will be cleared from the cairo context. See
Context::set_fill_rule() and Context::fill_preserve().</p>
</div><h4 id='method.fill_preserve' class='method'><code>fn <a href='#method.fill_preserve' class='fnname'>fill_preserve</a>(&amp;self)</code></h4>
<div class='docblock'><p>A drawing operator that fills the current path according to the current fill rule,
(each sub-path is implicitly closed before being filled). Unlike Context::fill(),
Context::fill_preserve() preserves the path within the cairo context.</p>

<p>See Context::set_fill_rule() and Context::fill().</p>
</div><h4 id='method.fill_extents' class='method'><code>fn <a href='#method.fill_extents' class='fnname'>fill_extents</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Computes a bounding box in user coordinates covering the area that would be affected,
(the &quot;inked&quot; area), by a Context::fill() operation given the current path and fill
parameters. If the current path is empty, returns an empty rectangle ((0,0), (0,0)).
Surface dimensions and clipping are not taken into account.</p>

<p>Contrast with Context::path_extents(), which is similar, but returns non-zero extents
for some paths with no inked area, (such as a simple line segment).</p>

<p>Note that Context::fill_extents() must necessarily do more work to compute the precise
inked areas in light of the fill rule, so Context::path_extents() may be more desirable
for sake of performance if the non-inked path extents are desired.</p>

<p>See Context::fill(), Context::set_fill_rule() and Context::fill_preserve().</p>
</div><h4 id='method.in_fill' class='method'><code>fn <a href='#method.in_fill' class='fnname'>in_fill</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Tests whether the given point is inside the area that would be affected by a
Context::fill() operation given the current path and filling parameters. Surface
dimensions and clipping are not taken into account.</p>

<p>See Context::fill(), Context::set_fill_rule() and Context::fill_preserve().</p>
</div><h4 id='method.mask' class='method'><code>fn <a href='#method.mask' class='fnname'>mask</a>(&amp;self, pattern: &amp;<a class='trait' href='../cairo/trait.Pattern.html' title='cairo::Pattern'>Pattern</a>)</code></h4>
<div class='docblock'><p>A drawing operator that paints the current source using the alpha channel of
pattern as a mask. (Opaque areas of pattern are painted with the source, transparent
areas are not painted.)</p>
</div><h4 id='method.paint' class='method'><code>fn <a href='#method.paint' class='fnname'>paint</a>(&amp;self)</code></h4>
<div class='docblock'><p>A drawing operator that paints the current source everywhere within the current clip region.</p>
</div><h4 id='method.paint_with_alpha' class='method'><code>fn <a href='#method.paint_with_alpha' class='fnname'>paint_with_alpha</a>(&amp;self, alpha: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>A drawing operator that paints the current source everywhere within the current clip region
using a mask of constant alpha value alpha . The effect is similar to Context::paint(), but
the drawing is faded out using the alpha value.</p>
</div><h4 id='method.stroke' class='method'><code>fn <a href='#method.stroke' class='fnname'>stroke</a>(&amp;self)</code></h4>
<div class='docblock'><p>A drawing operator that strokes the current path according to the current line width, line
join, line cap, and dash settings. After Context::stroke(), the current path will be cleared
from the cairo context. See Context::set_line_width(), Context::set_line_join(),
Context::set_line_cap(), Context::set_dash(), and Context::stroke_preserve().</p>

<p>Note: Degenerate segments and sub-paths are treated specially and provide a useful result.
These can result in two different situations:</p>

<ol>
<li><p>Zero-length &quot;on&quot; segments set in Context::set_dash(). If the cap style is LineCap::Round
or LineCap::Square then these segments will be drawn as circular dots or squares respectively.
In the case of LineCap::Square, the orientation of the squares is determined by the direction
of the underlying path.</p></li>
<li><p>A sub-path created by Context::move_to() followed by either a Context::close_path() or one
or more calls to Context::line_to() to the same coordinate as the Context::move_to(). If the
cap style is LineCap::Round then these sub-paths will be drawn as circular dots. Note that in
the case of LineCap::Square a degenerate sub-path will not be drawn at all, (since the correct
orientation is indeterminate).</p></li>
</ol>

<p>In no case will a cap style of LineCap::Butt cause anything to be drawn in the case of either
degenerate segments or sub-paths.</p>
</div><h4 id='method.stroke_preserve' class='method'><code>fn <a href='#method.stroke_preserve' class='fnname'>stroke_preserve</a>(&amp;self)</code></h4>
<div class='docblock'><p>A drawing operator that strokes the current path according to the current line width, line
join, line cap, and dash settings. Unlike Context::stroke(), Context::stroke_preserve()
preserves the path within the cairo context.</p>

<p>See Context::set_line_width(), Context::set_line_join(), Context::set_line_cap(),
Context::set_dash(), and Context::stroke_preserve().</p>
</div><h4 id='method.stroke_extents' class='method'><code>fn <a href='#method.stroke_extents' class='fnname'>stroke_extents</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Computes a bounding box in user coordinates covering the area that would be affected,
(the &quot;inked&quot; area), by a Context::stroke() operation given the current path and stroke
parameters. If the current path is empty, returns an empty rectangle ((0,0), (0,0)).
Surface dimensions and clipping are not taken into account.</p>

<p>Note that if the line width is set to exactly zero, then Context::stroke_extents() will
return an empty rectangle. Contrast with cairo_path_extents() which can be used to compute
the non-empty bounds as the line width approaches zero.</p>

<p>Note that cairo_stroke_extents() must necessarily do more work to compute the precise inked
areas in light of the stroke parameters, so cairo_path_extents() may be more desirable for
sake of performance if non-inked path extents are desired.</p>

<p>See Context::stroke(), Context::set_line_width(), Context::set_line_join(),
Context::set_line_cap(), Context::set_dash(), and Context::stroke_preserve().</p>
</div><h4 id='method.in_stroke' class='method'><code>fn <a href='#method.in_stroke' class='fnname'>in_stroke</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Tests whether the given point is inside the area that would be affected by a
Context::stroke() operation given the current path and stroking parameters. Surface
dimensions and clipping are not taken into account.</p>

<p>See Context::stroke(), Context::set_line_width(), Context::set_line_join(),
Context::set_line_cap(), Context::set_dash(), and Context::stroke_preserve().</p>
</div><h4 id='method.copy_page' class='method'><code>fn <a href='#method.copy_page' class='fnname'>copy_page</a>(&amp;self)</code></h4>
<div class='docblock'><p>Emits the current page for backends that support multiple pages, but doesn&#39;t clear
it, so, the contents of the current page will be retained for the next page too. Use
Context::show_page() if you want to get an empty page after the emission.</p>

<p>This is a convenience function that simply calls Surface::copy_page() on self&#39;s
target.</p>
</div><h4 id='method.show_page' class='method'><code>fn <a href='#method.show_page' class='fnname'>show_page</a>(&amp;self)</code></h4>
<div class='docblock'><p>Emits and clears the current page for backends that support multiple pages. Use
Context::copy_page() if you don&#39;t want to clear the page.</p>

<p>This is a convenience function that simply calls Surface::show_page() on self&#39;s
target.</p>
</div><h4 id='method.get_reference_count' class='method'><code>fn <a href='#method.get_reference_count' class='fnname'>get_reference_count</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a></code></h4>
<div class='docblock'><p>Returns the current reference count of self.</p>
</div><h4 id='method.translate' class='method'><code>fn <a href='#method.translate' class='fnname'>translate</a>(&amp;self, tx: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, ty: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Modifies the current transformation matrix (CTM) by translating the user-space
origin by (tx , ty ). This offset is interpreted as a user-space coordinate
according to the CTM in place before the new call to cairo_translate(). In other
words, the translation of the user-space origin takes place after any existing
transformation.</p>
</div><h4 id='method.scale' class='method'><code>fn <a href='#method.scale' class='fnname'>scale</a>(&amp;self, sx: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, sy: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Modifies the current transformation matrix (CTM) by scaling the X and Y user-space
axes by sx and sy respectively. The scaling of the axes takes place after any
existing transformation of user space.</p>
</div><h4 id='method.rotate' class='method'><code>fn <a href='#method.rotate' class='fnname'>rotate</a>(&amp;self, angle: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Modifies the current transformation matrix (CTM) by rotating the user-space axes by
angle radians. The rotation of the axes takes places after any existing transformation
of user space. The rotation direction for positive angles is from the positive X axis
toward the positive Y axis.</p>
</div><h4 id='method.identity_matrix' class='method'><code>fn <a href='#method.identity_matrix' class='fnname'>identity_matrix</a>(&amp;self)</code></h4>
<div class='docblock'><p>Resets the current transformation matrix (CTM) by setting it equal to the identity
matrix. That is, the user-space and device-space axes will be aligned and one user-space
unit will transform to one device-space unit.</p>
</div><h4 id='method.user_to_device' class='method'><code>fn <a href='#method.user_to_device' class='fnname'>user_to_device</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Transform a coordinate from user space to device space by multiplying the given point
by the current transformation matrix (CTM).</p>
</div><h4 id='method.user_to_device_distance' class='method'><code>fn <a href='#method.user_to_device_distance' class='fnname'>user_to_device_distance</a>(&amp;self, dx: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dy: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Transform a distance vector from user space to device space. This function is similar
to Context::user_to_device() except that the translation components of the CTM will
be ignored when transforming (dx ,dy ).</p>
</div><h4 id='method.device_to_user' class='method'><code>fn <a href='#method.device_to_user' class='fnname'>device_to_user</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Transform a coordinate from device space to user space by multiplying the given point
by the inverse of the current transformation matrix (CTM).</p>
</div><h4 id='method.device_to_user_distance' class='method'><code>fn <a href='#method.device_to_user_distance' class='fnname'>device_to_user_distance</a>(&amp;self, dx: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dy: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Transform a distance vector from device space to user space. This function is similar
to Context::device_to_user() except that the translation components of the inverse CTM
will be ignored when transforming (dx ,dy ).</p>
</div><h4 id='method.select_font_face' class='method'><code>fn <a href='#method.select_font_face' class='fnname'>select_font_face</a>(&amp;self, family: &amp;<a href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, slant: <a class='enum' href='../cairo/enums/enum.FontSlant.html' title='cairo::enums::FontSlant'>FontSlant</a>, weight: <a class='enum' href='../cairo/enums/enum.FontWeight.html' title='cairo::enums::FontWeight'>FontWeight</a>)</code></h4>
<div class='docblock'><p>Note: The Context::select_font_face() function call is part of what the cairo designers
call the &quot;toy&quot; text API. It is convenient for short demos and simple programs, but it
is not expected to be adequate for serious text-using applications.</p>

<p>Selects a family and style of font from a simplified description as a family name, slant
and weight. Cairo provides no operation to list available family names on the system (this
is a &quot;toy&quot;, remember), but the standard CSS2 generic family names, (&quot;serif&quot;, &quot;sans-serif&quot;,
&quot;cursive&quot;, &quot;fantasy&quot;, &quot;monospace&quot;), are likely to work as expected.</p>

<p>If family starts with the string &quot;cairo :&quot;, or if no native font backends are compiled in,
cairo will use an internal font family. The internal font family recognizes many modifiers
in the family string, most notably, it recognizes the string &quot;monospace&quot;. That is, the
family name &quot;cairo :monospace&quot; will use the monospace version of the internal font family.</p>

<p>For &quot;real&quot; font selection, see the font-backend-specific font_face_create functions for the
font backend you are using. (For example, if you are using the freetype-based cairo-ft font
backend, see Font::create_for_ft_face() or Font::create_for_pattern().) The resulting font
face could then be used with Context::scaled_font_create() and Context::set_scaled_font().</p>

<p>Similarly, when using the &quot;real&quot; font support, you can call directly into the underlying
font system, (such as fontconfig or freetype), for operations such as listing available
fonts, etc.</p>

<p>It is expected that most applications will need to use a more comprehensive font handling
and text layout library, (for example, pango), in conjunction with cairo.</p>

<p>If text is drawn without a call to Context::select_font_face(), (nor Context::set_font_face()
nor Context::set_scaled_font()), the default family is platform-specific, but is essentially
&quot;sans-serif&quot;. Default slant is FontSlant::Normal, and default weight is FontWeight::Normal.</p>

<p>This function is equivalent to a call to cairo_toy_font_face_create() followed by
Context::set_font_face().</p>
</div><h4 id='method.set_font_size' class='method'><code>fn <a href='#method.set_font_size' class='fnname'>set_font_size</a>(&amp;self, size: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Sets the current font matrix to a scale by a factor of size , replacing any font matrix
previously set with Context::set_font_size() or Context::set_font_matrix(). This results
in a font size of size user space units. (More precisely, this matrix will result in the
font&#39;s em-square being a size by size square in user space.)</p>

<p>If text is drawn without a call to Context::set_font_size(), (nor
Context::set_font_matrix() nor Context::set_scaled_font()), the default font size is 10.0.</p>
</div><h4 id='method.set_font_matrix' class='method'><code>fn <a href='#method.set_font_matrix' class='fnname'>set_font_matrix</a>(&amp;self, matrix: <a class='struct' href='../cairo/struct.Matrix.html' title='cairo::Matrix'>Matrix</a>)</code></h4>
<div class='docblock'><p>Sets the current font matrix to matrix . The font matrix gives a transformation from the
design space of the font (in this space, the em-square is 1 unit by 1 unit) to user space.
Normally, a simple scale is used (see Context::set_font_size()), but a more complex font
matrix can be used to shear the font or stretch it unequally along the two axes.</p>
</div><h4 id='method.get_font_matrix' class='method'><code>fn <a href='#method.get_font_matrix' class='fnname'>get_font_matrix</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.Matrix.html' title='cairo::Matrix'>Matrix</a></code></h4>
<div class='docblock'><p>Stores the current font matrix into matrix . See Context::set_font_matrix().</p>
</div><h4 id='method.set_font_options' class='method'><code>fn <a href='#method.set_font_options' class='fnname'>set_font_options</a>(&amp;self, options: <a class='struct' href='../cairo/struct.FontOptions.html' title='cairo::FontOptions'>FontOptions</a>)</code></h4>
<div class='docblock'><p>Sets a set of custom font rendering options for the Context. Rendering options are
derived by merging these options with the options derived from underlying surface;
if the value in options has a default value (like Antialias::Default), then the value
from the surface is used.</p>
</div><h4 id='method.get_font_options' class='method'><code>fn <a href='#method.get_font_options' class='fnname'>get_font_options</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.FontOptions.html' title='cairo::FontOptions'>FontOptions</a></code></h4>
<div class='docblock'><p>Retrieves font rendering options set via Context::set_font_options. Note that the returned
options do not include any options derived from the underlying surface; they are literally
the options passed to Context::set_font_options().</p>
</div><h4 id='method.set_font_face' class='method'><code>fn <a href='#method.set_font_face' class='fnname'>set_font_face</a>(&amp;self, font_face: <a class='struct' href='../cairo/struct.FontFace.html' title='cairo::FontFace'>FontFace</a>)</code></h4>
<div class='docblock'><p>Replaces the current FontFace object in the Context with font_face. The replaced
font face in the cairo_t will be destroyed if there are no other references to it.</p>
</div><h4 id='method.get_font_face' class='method'><code>fn <a href='#method.get_font_face' class='fnname'>get_font_face</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.FontFace.html' title='cairo::FontFace'>FontFace</a></code></h4>
<div class='docblock'><p>Gets the current font face for a Context object.</p>
</div><h4 id='method.set_scaled_font' class='method'><code>fn <a href='#method.set_scaled_font' class='fnname'>set_scaled_font</a>(&amp;self, scaled_font: <a class='struct' href='../cairo/struct.ScaledFont.html' title='cairo::ScaledFont'>ScaledFont</a>)</code></h4>
<div class='docblock'><p>Replaces the current font face, font matrix, and font options in the Context with
those of the ScaledFont object. Except for some translation, the current CTM of the
Context should be the same as that of the ScaledFont object, which can be accessed
using Context::scaled_font_get_ctm().</p>
</div><h4 id='method.get_scaled_font' class='method'><code>fn <a href='#method.get_scaled_font' class='fnname'>get_scaled_font</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.ScaledFont.html' title='cairo::ScaledFont'>ScaledFont</a></code></h4>
<div class='docblock'><p>Gets the current scaled font for a Context.</p>
</div><h4 id='method.show_text' class='method'><code>fn <a href='#method.show_text' class='fnname'>show_text</a>(&amp;self, text: &amp;<a href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>A drawing operator that generates the shape from a string of UTF-8 characters,
rendered according to the current FontFace, FontSize (FontMatrix), and
font_options.</p>

<p>This function first computes a set of glyphs for the string of text. The first
glyph is placed so that its origin is at the current point. The origin of each
subsequent glyph is offset from that of the previous glyph by the advance values
of the previous glyph.</p>

<p>After this call the current point is moved to the origin of where the next glyph
would be placed in this same progression. That is, the current point will be at
the origin of the final glyph offset by its advance values. This allows for easy
display of a single logical string with multiple calls to Context::show_text().</p>

<p>Note: The Context::show_text() function call is part of what the cairo designers
call the &quot;toy&quot; text API. It is convenient for short demos and simple programs,
but it is not expected to be adequate for serious text-using applications. See
Context::show_glyphs() for the &quot;real&quot; text display API in cairo.</p>
</div><h4 id='method.show_glyphs' class='method'><code>fn <a href='#method.show_glyphs' class='fnname'>show_glyphs</a>(&amp;self, glyphs: <a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='struct' href='../cairo/struct.Glyph.html' title='cairo::Glyph'>Glyph</a><a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>)</code></h4>
<h4 id='method.show_text_glyphs' class='method'><code>fn <a href='#method.show_text_glyphs' class='fnname'>show_text_glyphs</a>(&amp;self, text: &amp;<a href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, glyphs: <a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='struct' href='../cairo/struct.Glyph.html' title='cairo::Glyph'>Glyph</a><a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>, clusters: <a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='struct' href='../cairo/struct.TextCluster.html' title='cairo::TextCluster'>TextCluster</a><a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>, cluster_flags: <a class='enum' href='../cairo/enums/enum.TextClusterFlags.html' title='cairo::enums::TextClusterFlags'>TextClusterFlags</a>)</code></h4>
<div class='docblock'><p>A drawing operator that generates the shape from an array of glyphs, rendered
according to the current font face, font size (font matrix), and font options.</p>
</div><h4 id='method.font_extents' class='method'><code>fn <a href='#method.font_extents' class='fnname'>font_extents</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.FontExtents.html' title='cairo::FontExtents'>FontExtents</a></code></h4>
<div class='docblock'><p>Gets the font extents for the currently selected font.</p>
</div><h4 id='method.text_extents' class='method'><code>fn <a href='#method.text_extents' class='fnname'>text_extents</a>(&amp;self, text: &amp;<a href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='struct' href='../cairo/struct.TextExtents.html' title='cairo::TextExtents'>TextExtents</a></code></h4>
<div class='docblock'><p>Gets the extents for a string of text. The extents describe a user-space rectangle
that encloses the &quot;inked&quot; portion of the text, (as it would be drawn by
Context::show_text()). Additionally, the x_advance and y_advance values indicate
the amount by which the current point would be advanced by Context::show_text().</p>

<p>Note that whitespace characters do not directly contribute to the size of the rectangle
(extents.width and extents.height). They do contribute indirectly by changing the
position of non-whitespace characters. In particular, trailing whitespace characters
are likely to not affect the size of the rectangle, though they will affect the
x_advance and y_advance values.</p>
</div><h4 id='method.glyph_extents' class='method'><code>fn <a href='#method.glyph_extents' class='fnname'>glyph_extents</a>(&amp;self, glyphs: <a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='struct' href='../cairo/struct.Glyph.html' title='cairo::Glyph'>Glyph</a><a href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='struct' href='../cairo/struct.TextExtents.html' title='cairo::TextExtents'>TextExtents</a></code></h4>
<div class='docblock'><p>Gets the extents for an array of glyphs. The extents describe a user-space rectangle
that encloses the &quot;inked&quot; portion of the glyphs, (as they would be drawn by
Context::show_glyphs()). Additionally, the x_advance and y_advance values indicate
the amount by which the current point would be advanced by Context::show_glyphs().</p>

<p>Note that whitespace glyphs do not contribute to the size of the rectangle
(extents.width and extents.height).</p>
</div><h4 id='method.copy_path' class='method'><code>fn <a href='#method.copy_path' class='fnname'>copy_path</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.Path.html' title='cairo::Path'>Path</a></code></h4>
<div class='docblock'><p>Creates a copy of the current path and returns it to the user as a Path. See
PathData for hints on how to iterate over the returned data structure.</p>

<p>This function will always return a valid pointer, but the result will have no
data (data==NULL and num_data==0), if either of the following conditions hold:</p>

<ol>
<li>If there is insufficient memory to copy the path. In this case path.status
will be set to Status::NoMemory.</li>
<li>If self is already in an error state. In this case path.status will contain
the same status that would be returned by cairo_status().</li>
</ol>
</div><h4 id='method.copy_path_flat' class='method'><code>fn <a href='#method.copy_path_flat' class='fnname'>copy_path_flat</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.Path.html' title='cairo::Path'>Path</a></code></h4>
<div class='docblock'><p>Gets a flattened copy of the current path and returns it to the user as a Path.
See PathData for hints on how to iterate over the returned data structure.</p>

<p>This function is like cairo_copy_path() except that any curves in the path will
be approximated with piecewise-linear approximations, (accurate to within the
current tolerance value). That is, the result is guaranteed to not have any
elements of type Path::CurveTo which will instead be replaced by a series of
Path::Line elements.</p>

<p>This function will always return a valid pointer, but the result will have no
data (data==NULL and num_data==0), if either of the following conditions hold:</p>

<ol>
<li>If there is insufficient memory to copy the path. In this case path-&gt;status
will be set to Status::NoMemory.</li>
<li>If self is already in an error state. In this case path-&gt;status will contain
the same status that would be returned by Context::status().</li>
</ol>
</div><h4 id='method.append_path' class='method'><code>fn <a href='#method.append_path' class='fnname'>append_path</a>(&amp;self, path: &amp;<a class='struct' href='../cairo/struct.Path.html' title='cairo::Path'>Path</a>)</code></h4>
<div class='docblock'><p>Append the path onto the current path. The path may be either the return value
from one of Context::copy_path() or Context::copy_path_flat() or it may be
constructed manually. See Path for details on how the path data structure should
be initialized, and note that path.status must be initialized to Status::Success.</p>
</div><h4 id='method.has_current_point' class='method'><code>fn <a href='#method.has_current_point' class='fnname'>has_current_point</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns whether a current point is defined on the current path. See
Context::get_current_point() for details on the current point.</p>
</div><h4 id='method.get_current_point' class='method'><code>fn <a href='#method.get_current_point' class='fnname'>get_current_point</a>(&amp;self) -&gt; <a href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(<a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</a></code></h4>
<div class='docblock'><p>Gets the current point of the current path, which is conceptually the final
point reached by the path so far.</p>

<p>The current point is returned in the user-space coordinate system. If there is
no defined current point or if cr is in an error status, x and y will both be set
to 0.0. It is possible to check this in advance with cairo_has_current_point().</p>

<p>Most path construction functions alter the current point. See the following for
details on how they affect the current point: Context::new_path(),
Context::new_sub_path(), Context::append_path(), Context::close_path(),
Context::move_to(), Context::line_to(), Context::curve_to(), cairo_rel_move_to(),
Context::rel_line_to(), Context::rel_curve_to(), Context::arc(),
Context::arc_negative(), Context::rectangle(), Context::text_path(),
Context::glyph_path(), Context::stroke_to_path().</p>

<p>Some functions use and alter the current point but do not otherwise change current path: Context::show_text().</p>

<p>Some functions unset the current path and as a result, current point: Context::fill(), Context::stroke().</p>
</div><h4 id='method.new_path' class='method'><code>fn <a href='#method.new_path' class='fnname'>new_path</a>(&amp;self)</code></h4>
<div class='docblock'><p>Clears the current path. After this call there will be no path and no current point.</p>
</div><h4 id='method.new_sub_path' class='method'><code>fn <a href='#method.new_sub_path' class='fnname'>new_sub_path</a>(&amp;self)</code></h4>
<div class='docblock'><p>Begin a new sub-path. Note that the existing path is not affected. After this call
there will be no current point.</p>

<p>In many cases, this call is not needed since new sub-paths are frequently started
with Context::move_to().</p>

<p>A call to Context::new_sub_path() is particularly useful when beginning a new
sub-path with one of the Context::arc() calls. This makes things easier as it is
no longer necessary to manually compute the arc&#39;s initial coordinates for a call to
Context::move_to().</p>
</div><h4 id='method.close_path' class='method'><code>fn <a href='#method.close_path' class='fnname'>close_path</a>(&amp;self)</code></h4>
<div class='docblock'><p>Adds a line segment to the path from the current point to the beginning of
the current sub-path, (the most recent point passed to cairo_move_to()), and
closes this sub-path. After this call the current point will be at the joined
endpoint of the sub-path.</p>

<p>The behavior of Context::close_path() is distinct from simply calling
Context::line_to() with the equivalent coordinate in the case of stroking. When
a closed sub-path is stroked, there are no caps on the ends of the sub-path.
Instead, there is a line join connecting the final and initial segments of the
sub-path.</p>

<p>If there is no current point before the call to Context::close_path(), this
function will have no effect.</p>

<p>Note: As of cairo version 1.2.4 any call to Context::close_path() will place
an explicit MOVE_TO element into the path immediately after the CLOSE_PATH
element, (which can be seen in Context::copy_path() for example). This can
simplify path processing in some cases as it may not be necessary to save the
&quot;last move_to point&quot; during processing as the MOVE_TO immediately after the
CLOSE_PATH will provide that point.</p>
</div><h4 id='method.arc' class='method'><code>fn <a href='#method.arc' class='fnname'>arc</a>(&amp;self, xc: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, yc: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, radius: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, angle1: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, angle2: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Adds a circular arc of the given radius to the current path. The arc is centered
at (xc , yc ), begins at angle1 and proceeds in the direction of increasing
angles to end at angle2 . If angle2 is less than angle1 it will be progressively
increased by 2*M_PI until it is greater than angle1 .</p>

<p>If there is a current point, an initial line segment will be added to the path
to connect the current point to the beginning of the arc. If this initial line is
undesired, it can be avoided by calling Context::new_sub_path() before calling
Context::arc().</p>

<p>Angles are measured in radians. An angle of 0.0 is in the direction of the
positive X axis (in user space). An angle of M_PI/2.0 radians (90 degrees) is
in the direction of the positive Y axis (in user space). Angles increase in the
direction from the positive X axis toward the positive Y axis. So with the default
transformation matrix, angles increase in a clockwise direction.</p>

<p>(To convert from degrees to radians, use degrees * (M_PI / 180.).)</p>

<p>This function gives the arc in the direction of increasing angles; see
Context::arc_negative() to get the arc in the direction of decreasing angles.</p>

<p>The arc is circular in user space. To achieve an elliptical arc, you can scale
the current transformation matrix by different amounts in the X and Y directions.
For example, to draw an ellipse in the box given by x , y , width , height :</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>cr</span>.<span class='ident'>save</span>();
<span class='ident'>cr</span>.<span class='ident'>translate</span>(<span class='ident'>x</span> <span class='op'>+</span> <span class='ident'>width</span> <span class='op'>/</span> <span class='number'>2.</span>, <span class='ident'>y</span> <span class='op'>+</span> <span class='ident'>height</span> <span class='op'>/</span> <span class='number'>2.</span>);
<span class='ident'>cr</span>.<span class='ident'>scale</span>(<span class='ident'>width</span> <span class='op'>/</span> <span class='number'>2.</span>, <span class='ident'>height</span> <span class='op'>/</span> <span class='number'>2.</span>);
<span class='ident'>cr</span>.<span class='ident'>arc</span>(<span class='number'>0.</span>, <span class='number'>0.</span>, <span class='number'>1.</span>, <span class='number'>0.</span>, <span class='number'>2</span> <span class='op'>*</span> <span class='ident'>M_PI</span>);
<span class='ident'>cr</span>.<span class='ident'>restore</span>();</pre>
</div><h4 id='method.arc_negative' class='method'><code>fn <a href='#method.arc_negative' class='fnname'>arc_negative</a>(&amp;self, xc: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, yc: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, radius: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, angle1: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, angle2: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Adds a circular arc of the given radius to the current path. The arc is centered
at (xc , yc ), begins at angle1 and proceeds in the direction of decreasing
angles to end at angle2 . If angle2 is greater than angle1 it will be
progressively decreased by 2*M_PI until it is less than angle1.</p>

<p>See Context::arc() for more details. This function differs only in the direction
of the arc between the two angles.</p>
</div><h4 id='method.curve_to' class='method'><code>fn <a href='#method.curve_to' class='fnname'>curve_to</a>(&amp;self, x1: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y1: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, x2: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y2: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, x3: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y3: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Adds a cubic Bézier spline to the path from the current point to position
(x3 , y3 ) in user-space coordinates, using (x1 , y1 ) and (x2 , y2 ) as the
control points. After this call the current point will be (x3 , y3 ).</p>

<p>If there is no current point before the call to Context::curve_to() this function
will behave as if preceded by a call to Context::move_to(cr , x1 , y1 ).</p>
</div><h4 id='method.line_to' class='method'><code>fn <a href='#method.line_to' class='fnname'>line_to</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Adds a line to the path from the current point to position (x , y ) in user-space
coordinates. After this call the current point will be (x , y ).</p>

<p>If there is no current point before the call to cairo_line_to() this function
will behave as cairo_move_to(cr , x , y ).</p>
</div><h4 id='method.move_to' class='method'><code>fn <a href='#method.move_to' class='fnname'>move_to</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Begin a new sub-path. After this call the current point will be (x , y ).</p>
</div><h4 id='method.rectangle' class='method'><code>fn <a href='#method.rectangle' class='fnname'>rectangle</a>(&amp;self, x: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, width: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, height: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Adds a closed sub-path rectangle of the given size to the current path at
position (x , y ) in user-space coordinates.</p>

<p>This function is logically equivalent to:</p>
<pre class='rust rust-example-rendered'>
<span class='ident'>cr</span>.<span class='ident'>move_to</span>(, <span class='ident'>x</span>, <span class='ident'>y</span>);
<span class='ident'>cr</span>.<span class='ident'>rel_line_to</span>(<span class='ident'>width</span>, <span class='number'>0</span>);
<span class='ident'>cr</span>.<span class='ident'>rel_line_to</span>(<span class='number'>0</span>, <span class='ident'>height</span>);
<span class='ident'>cr</span>.<span class='ident'>rel_line_to</span>(<span class='op'>-</span><span class='ident'>width</span>, <span class='number'>0</span>);
<span class='ident'>cr</span>.<span class='ident'>close_path</span>();</pre>
</div><h4 id='method.text_path' class='method'><code>fn <a href='#method.text_path' class='fnname'>text_path</a>(&amp;self, str_: &amp;<a href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>Adds closed paths for the glyphs to the current path. The generated path if
filled, achieves an effect similar to that of Context::show_glyphs().</p>
</div><h4 id='method.rel_curve_to' class='method'><code>fn <a href='#method.rel_curve_to' class='fnname'>rel_curve_to</a>(&amp;self, dx1: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dy1: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dx2: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dy2: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dx3: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dy3: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Relative-coordinate version of Context::curve_to(). All offsets are relative to
the current point. Adds a cubic Bézier spline to the path from the current point
to a point offset from the current point by (dx3 , dy3 ), using points offset by
(dx1 , dy1 ) and (dx2 , dy2 ) as the control points. After this call the current
point will be offset by (dx3 , dy3 ).</p>

<p>Given a current point of (x, y),
Context::rel_curve_to(dx1 , dy1 , dx2 , dy2 , dx3 , dy3 ) is logically
equivalent to Context::curve_to(x+dx1 , y+dy1 , x+dx2 , y+dy2 , x+dx3 , y+dy3 ).</p>

<p>It is an error to call this function with no current point. Doing so will cause
self to shutdown with a status of Status::NoCurrentPoint.</p>
</div><h4 id='method.rel_line_to' class='method'><code>fn <a href='#method.rel_line_to' class='fnname'>rel_line_to</a>(&amp;self, dx: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dy: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Relative-coordinate version of Context::line_to(). Adds a line to the path from
the current point to a point that is offset from the current point by (dx , dy )
in user space. After this call the current point will be offset by (dx , dy ).</p>

<p>Given a current point of (x, y), Context::rel_line_to(dx , dy ) is logically
equivalent to Context::line_to( x + dx , y + dy ).</p>

<p>It is an error to call this function with no current point. Doing so will cause
self to shutdown with a status of Status::NoCurrentPoint.</p>
</div><h4 id='method.rel_move_to' class='method'><code>fn <a href='#method.rel_move_to' class='fnname'>rel_move_to</a>(&amp;self, dx: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, dy: <a href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Begin a new sub-path. After this call the current point will offset by (x , y ).</p>

<p>Given a current point of (x, y), Context::rel_move_to(dx , dy ) is logically
equivalent to Context::move_to(x + dx , y + dy ).</p>

<p>It is an error to call this function with no current point. Doing so will
cause self to shutdown with a status of Status::NoCurrenPoint.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl&lt;'a&gt; <a class='trait' href='../cairo/glib/translate/trait.ToGlibPtr.html' title='cairo::glib::translate::ToGlibPtr'>ToGlibPtr</a>&lt;'a, <a href='https://doc.rust-lang.org/nightly/std/primitive.pointer.html'>*mut <a class='struct' href='../cairo/ffi/struct.cairo_t.html' title='cairo::ffi::cairo_t'>cairo_t</a></a>&gt; for &amp;'a <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h3><div class='impl-items'><h4 id='assoc_type.Storage' class='type'><code>type Storage = &amp;'a <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h4>
<h4 id='method.to_glib_none' class='method'><code>fn <a href='../cairo/glib/translate/trait.ToGlibPtr.html#method.to_glib_none' class='fnname'>to_glib_none</a>(&amp;self) -&gt; <a class='struct' href='../cairo/glib/translate/struct.Stash.html' title='cairo::glib::translate::Stash'>Stash</a>&lt;'a, <a href='https://doc.rust-lang.org/nightly/std/primitive.pointer.html'>*mut <a class='struct' href='../cairo/ffi/struct.cairo_t.html' title='cairo::ffi::cairo_t'>cairo_t</a></a>, &amp;'a <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a>&gt;</code></h4>
<h4 id='method.to_glib_full' class='method'><code>fn <a href='../cairo/glib/translate/trait.ToGlibPtr.html#method.to_glib_full' class='fnname'>to_glib_full</a>(&amp;self) -&gt; P</code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='../cairo/glib/translate/trait.FromGlibPtr.html' title='cairo::glib::translate::FromGlibPtr'>FromGlibPtr</a>&lt;<a href='https://doc.rust-lang.org/nightly/std/primitive.pointer.html'>*mut <a class='struct' href='../cairo/ffi/struct.cairo_t.html' title='cairo::ffi::cairo_t'>cairo_t</a></a>&gt; for <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h3><div class='impl-items'><h4 id='method.from_glib_none' class='method'><code>unsafe fn <a href='../cairo/glib/translate/trait.FromGlibPtr.html#method.from_glib_none' class='fnname'>from_glib_none</a>(ptr: <a href='https://doc.rust-lang.org/nightly/std/primitive.pointer.html'>*mut <a class='struct' href='../cairo/ffi/struct.cairo_t.html' title='cairo::ffi::cairo_t'>cairo_t</a></a>) -&gt; <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h4>
<h4 id='method.from_glib_full' class='method'><code>unsafe fn <a href='../cairo/glib/translate/trait.FromGlibPtr.html#method.from_glib_full' class='fnname'>from_glib_full</a>(ptr: <a href='https://doc.rust-lang.org/nightly/std/primitive.pointer.html'>*mut <a class='struct' href='../cairo/ffi/struct.cairo_t.html' title='cairo::ffi::cairo_t'>cairo_t</a></a>) -&gt; <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a>&gt; for <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h3><div class='impl-items'><h4 id='method.as_ref' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html#method.as_ref' class='fnname'>as_ref</a>(&amp;self) -&gt; &amp;<a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../cairo/struct.Context.html' title='cairo::Context'>Context</a></code></h4>
<h4 id='method.clone_from' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div>
            <div class="shortcuts">
                <h1>Keyboard Shortcuts</h1>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h1>Search Tricks</h1>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code>)
                </p>
            </div>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "cairo";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>